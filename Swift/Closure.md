# 📖 Closure

스위프트에서는 함수가 일급 객체이기 때문에 함수는 타입이 가지는 모든 것을 가질 수 있다. 어디서든지 함수를 타입으로 사용할 수 있다. 어떤 것이던 함수 타입으로 선언만 하면 된다. 그리고 인자와 리턴값을 정해주면 된다. 타입을 쓸 수 있는 어느곳이든 사용할 수 있다. 또, 다른 변수처럼 함수의 인자 등에 사용할 수 있다.

<br />

```swift
var operation: (Double) -> Double
//Double을 받아 Double을 리턴하는 함수형인 변수를 선언

operation = sqrt
//sqrt(Double) -> Double 제곱근 값 리턴하는 함수
//sqrt도 (Double) -> Double 형 함수이기 때문에 operation에 지정해줄 수 있다.

let result = operation(4.0) 
//함수 변수도 함수처럼 부르면 사용할 수 있다.
// result = 2.0
```

<br />

만약에 부호를 바꾸는 함수를 만들고싶다! 할 때 아래와 같이 만들 수 있다.

```swift
func changeSign(operand: Double) -> Double { return -operand }

var operation: (Double) -> Double
operation = changeSign
let result = operation(4.0) 	//result = -4.0
```

하지만 이렇게 하는건........넘 귀찮아......왜냐면 우리는 단지 부호가 바뀌는 간단한 기능만 원하는데요!
이럴 때 클로저를 사용한다!

<br />

클로저는 인라인 함수이다. 주변의 상태를 capture한다는 점에서 조금 특별하긴 하지만 어쨌든 인라인 함수이다. 그래서 그 문법을 살펴보면 changeSign을 그대로 가져와서 쓰면 된다! 따로 함수를 가지지 않아도 된다. 그냥 이름만 빼고 그대로 가져온다.

```swift
var operation: (Double) -> Double
operation = { (operand: Double) -> Double in return -operand }
//'{'를 맨 앞에 적고 그 뒤에 인자와 리턴 목록을 적은 후 'in'과 함께 changeSign의 구현부를 그대로 옮겨 온 후 '}' 괄호를 닫는다.
let result = operand(4.0)
```

클로저를 사용하면 어떤 함수든 놓을 수 있다.

<br />

## Closure 축약

스위프트에는 타입 추론 기능이 있다. 스위프트는 무슨 일이 일어나는지 아주 잘 알고있다. 스위프트는 이미 operation이 double을 리턴하는 것을 알고 있다. 그래서 리턴값의 타입을 적지않아도 되고, 그리고 또 피연산자가 더블이라는 것도 알고있기 때문에 이것 또한 적지 않아도 된다. 또한 이 함수가 어떤 타입을 리턴할 것인지 이미 알고있기 때문에 return 키워드도 필요하지 않다.

```swift
var operation: (Double) -> Double

operation = { (operand: Double) -> Double in return -operand}
operation = { (operand: Double) in return - operand}
operation = { (operand) in return -operand}
operation = { (operand) in -operand}
//위 4개의 함수는 모두 같은 의미이다.
```

<br />

또한 스위프트는 이런 내장 함수를 계속 가지기 원한다는 것을 알고 있다. 그리고 인자의 이름을 생각하는 것은 귀찮은 일이다. operand라는 이름을 생각해 내야하는 것 처럼 말이다.

그래서 첫 번째 파라미터의 이름을 `$0`로, 두 번째 것을 `$1`, 세 번째 것을 `$2` ...로 바꿀 수 있다!!

```swift
operation = { (operand) in -operand }
//여기서 첫 번째 파라미터 operand의 이름이 $0으로 변경된다.
operation = { -$0 }
//이렇게 함으로써 더 이상 in도 적을 필요가 없어진다.
```

<br />

<br />

## 그렇다면 왜 클로저를 사용할까? 왜 함수를 인자로 넘겨줘야 하는 걸까?

왜냐하면 함수에게 무엇을 할지 알려줘야 하기 때문이다. 함수는 무엇을 할지 알려주는 좋은 방법이다. 그렇다면 왜 무엇을 할지 알려야 하나요? 어쩌면 오류가 있을 때 어떤 일을 해야 할지 알아야 할 수도 있다. 어떤 작업을 했을 때 오류가 발생하면 함수를 불러와서 처리하는 것이다. 어떤 작업을 해야하는지 알려고 할 때는 종종 시간이 걸리는 작업을 하게 된다. 네트워크에 들어가서 어떤 것을 다운로드 하고 그것이 완료되면 알려주겠죠. 함수를 불러와서 그 작업을 하는 것이다. 또 다른 경우는 어떤 일을 반복적으로 수행할 때 입니다. 같은 일을 계속해서 하는 것이다. 그래서 어떤 일을 반복해야 해야할 지 알려주는 것이다.

배열을 실제로는 컬렉션이지만 어쨌든 배열에는 map이라는 메소드가 있다. map은 인자를 하나만 받고 그 인자는 메소드다. 그리고 그 함수를 배열의 각 요소에 적용해서 새로운 배열을 생성한다. 그 배열의 모든 요소는 어떤 함수가 적용되어 있는 것이다. 다시 말해서 배열로 함수를 받아서 모든 요소에 적용하는 것이다.

```swift
let primes = [2.0, 3.0, 5.0, 7.0, 11.0]
let negativePrimes = primes.map({ -$0 })
//[-2.0, -3.0, -5.0, -7.0, -11.0]
let invertedPrimes = primes.map() { 1.0/$0 }
//[0.5, 0.333, 0.2, etc...]
let primeStrings = primes.map{String($0)}
//["2.0", "3.0", "5.0", ...]

//트레일링 클로저 문법
//1) 만약 어떤한 함수라도 마지막 인자가 클로저라면 클로저를 괄호 밖으로 내놓아도 된다.
// -> map() {}
//2) 만약 유일한 인자라면 괄호 자체를 빼버려도 된다.
// -> map{}
```

<br />

클로저의 또 다른 멋진 용도는 속성 초기화다. 만일 어떤 속성을 다른 어떤 것으로 초기화하고 싶은데 그냥 한 줄로는 어떻게 할 수 없을 때, 속성을 클로저를 실행하는 것으로 놓아도 된다. 그럼 클로저가 자동으로 인자가 없는 클로저로써 속성을 초기화하기에 적절한 타입을 리턴하게 된다. 클로저에서는 원하는 어떤 것 이든 할 수 있고, 그냥 올바른 타입을 리턴하면 된다. 그리고 괄호를 통해서 바로 실행해주면 된다.

```swift
var someProperty: Type = {
  
}() 	//마지막에 괄호를 열고닫아서 클로저를 즉시 실행하도록 해준다.
```

이런 클로저는 lazy property에서 정말 유용하다!!!! 왜냐면 누군가가 요청하기 전에는 실행되지 않기 때문이다

<br /><br />

## Value Capture

클로저를 사용할 때 주의해야할 점은 클로저는 주변 변수를 포착한다는 것이다. 클로저는 코드 안에 내장된 함수이다. 지역 변수나 인스턴스 변수가 클래스 안에 있다면 클로저 안에서 사용할 수 있다. 그리고 이 프로퍼티들은 클로저가 남아있는 한 계속해서 유지가 된다. 

클로저는 타입을 가져서 배열이나 딕셔너리를 가질 수 있는데 클로저는 레퍼런스 타입이다!!!!!!!!! (스위프트의 레퍼런스 타입은 클래스, 클로저 두 가지 뿐이다!) 이 의미는 배열 안에 넣게 된다면 클로저가 힙 안에 들어간다는 것이다. 그래서 배열이 실제로는 클로저의 포인터를 가지고있게 된다. 클로저에서 주변 코드로부터 변수를 받았다면 그 변수들도 힙 내에 존재하게 된다. 왜냐하면 클로저도 함수이기 때문이다.

```swift
var ltuae = 42
operation = { ltuae * $0 }
//클로저에서 ltuae라는 지역변수를 이용하고 있다.
//이 함수를 배열에 넣게 되면?
arrayOfOperations.append(operation)
//이후에 배열로부터 꺼내서 실행하게 된다.
//그래서 ltuae는 힙 내에 들어가서 클로저가 없어질 때 까지 유지된다.
```

연산의 배열이 있는 클래스를 받을 때 메모리 사이클이 발생할 수 있다. 연산이 있는 배열의 클래스를 받게 되면 클로저가 그 클래스를 힙 안에 넣게 된다. 그리고 배열의 클래스가 또 클래스를 힙에 넣게 된다. 배열 안에서 서로를 가리키게 된다. 메모리 사이클이 발생한다. 누군가 클로저를 삭제하기 전에는 빠져나올 수 없다.

이런 사이클을 빠져나오는 방법으로는 capture list에 해당 변수를  `weak`, `unowned` 키워드를 사용해서 선언해주면 된다.

[메모리 사이클 참고](https://github.com/Soojung-Shin/TIL/blob/master/Swift/Closure%20Capturing%20%26%20Memory%20Cycle.md)
