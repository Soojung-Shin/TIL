# RxSwift & Asynchronous programming

RxSwift란 관찰 가능한 시퀀스와 functional 스타일의 오퍼레이터를 사용해서 비동기 및 이벤트 기반 코드를 작성하기 위한 라이브러리로서 스케줄러를 통해 매개변수화된 실행을 할 수 있습니다.

RxSwift는 본질적으로, 코드가 새 데이터에 반응하고, 순차적이고 독립된 방식으로 처리됨으로서 비동기 프로그램을 개발하는 것을 단순화합니다. 즉, RxSwift는 비동기 코드를 작성하는 것을 도와준다는 것..!

<br /><br /><br />

## asynchronous programming

예를 들어서 iOS 앱에서 버튼 탭에 반응하고, 텍스트필드가 포커스를 잃었을 때 키보드가 애니메이팅되고, 인터넷에서 사진을 다운로드 받고, 디스크에 데이터 비트들을 저장하고, 오디오를 실행하는 등 모든 일은 동시에 일어나는 것 처럼 보입니다. 키보드가 화면에서 사라지는 애니메이션 중에서도 오디오는 멈추지 않습니다.

프로그램의 모든 부분들이 다른 실행을 차단하지 않습니다. iOS는 여러 스레드에서 각기 다른 작업들을 수행할 수 있게 하고, 기기 CPU의 다른 코어에서 작업을 수행할 수 있게 하는 다양한 API들을 제공합니다.

그러나 병렬적으로 실행되는 코드를 작성하는 것은 특히 여러 코드가 동일한 데이터에 접근해 작업해야 하는 경우는, 꽤나 복잡합니다. 어떤 코드가 데이터를 먼저 업데이트 하는지, 또 어떤 코드가 가장 최근의 값을 읽는지는 고민해야 할 문제가 됩니다.

<br /><br /><br />

## Cocoa and UIKit asynchronous APIs

애플의 iOS SDK는 비동기 코드를 작성을 도와주는 여러 API를 제공합니다. 프로젝트에 이런 API를 사용했을 것이고, 모바일 앱을 만드는데 너무 기본적인 것들이라 깊게 생각하지 않았을 수도 있습니다.

- **NotificationCenter**

  하나의 이벤트가 발생했을 때 특정 코드들을 실행시킬 수 있습니다. 예를 들어 사용자가 기기를 회전시키거나, 키보드를 숨기거나 보이거나 하는 작업들에 대한 이벤트를 처리할 수 있습니다.

- **Delegate pattern**

  다른 객체를 대신해서 일하거나, 함께 일하면서 작업을 대신 처리하게 하는 패턴을 말합니다. 예를 들어 app delegate에서 remote notification이 도착하면 어떤 작업을 해야할지 정의하지만, 우리는 그 코드가 언제 실행되는지, 몇 번 실행될지는 알 수 없습니다.

- **Grand Central Dispatch(GCD)**

  작업의 실행을 추상화하는데 도움을 줍니다. Serial Queue에서 순차적으로 실행되도록 스케줄링 하거나, 우선 순위가 다른 여러 Queue에서 작업들을 동시에 수행하도록 할 수도 있습니다.

- **Closure**

  분리된 코드 조각을 만들어 전달할 수 있고, 다른 객체가 이걸 실행할지 말지, 몇 번 실행할지, 어떤 컨텍스트 안에서 실행할지 등등을 결정할 수 있다.

<br /><br />

대부분의 일반적인 코드는 일부 작업을 비동기적으로 실행하고, 모든 UI 이벤트는 본질적으로 비동기적이기 때문에 전체 어플리케이션의 코드가 언제 어떤 순서로 실행될지에 대해서는 예측이 불가능합니다.

결국 어플리케이션의 코드는 사용자의 입력, 네트워킹, OS 이벤트 등의 외부적인 요소에 의해서 다르게 실행됩니다. 사용자가 앱을 실행할 때마다 이런 외부적인 요소들에 따라 코드가 완전히 다른 순서로 실행될 수 있습니다.

좋은 비동기 코드를 짜는 것이 불가능하다는 것이 아니라, 애플이 제공해주는 좋은 API들이 있지만 문제는 이런 API로 복잡한 비동기 코드를 부분적으로 작성하는게 어렵다는 이야기..

<p align="center"><img width="657" alt="image-20200210161226573" src="https://user-images.githubusercontent.com/16719527/74135062-f7ee0800-4c2e-11ea-9bee-da30fefceb72.png"></p>

delegate를 사용하는 것은 하나의 특정한 패턴을 적용시키는 것인데, 클로저, NotificationCenter를 구독하는 것 또한 마찬가지 입니다. 모든 비동기 API에 대한 보편적인 언어가 없기 때문에 코드를 읽거나 이해하고 실행에 대해서 추론하는 것이 어려워집니다.

<br /><br /><br />

## Synchronous code VS Asynchronous code

### Synchronous code (동기식 코드)

하나의 배열의 각 요소들에 작업을 하는 것은 여러번 해봤을 작업입니다. 간단해 보이지만 해당 작업이 동기적이어야 하고, 해당 컬렉션이 순회 작업을 하는 동안 immutable 해야하는 것을 보장해야 합니다.

이것이 무엇을 의미하냐하면, 컬렉션을 순회할 때 우리는 모든 요소가 존재하는지를 확인할 필요가 없으며, 다른 스레드가 컬렉션의 앞에 어떤 요소를 넣었을 때 작업을 리와인드 할 필요가 없습니다. 루프의 시작 부분에서 항상 컬렉션 전체를 순회할 것이라고 가정합니다.

```swift
var array = [1, 2, 3]
for number in array {
  print(number)
  array = [4, 5, 6]
}
print(array)

/*
1
2
3
[4, 5, 6]
*/
```

`array`가 `for` 문 안에서 mutable 한가요? 컬렉션이 루프를 순회하는 동안에 계속 바뀌나요? 모든 명령의 실행 순서는 무엇일까요? 필요한 경우 `number`를 수정할 수 있을까요?

<br /><br />

### Asynchronous code (비동기식 코드)

위에서 봤던 것과 비슷한 코드를 생각해봅시다. 하지만 순회의 각 작업이 버튼을 누르는 이벤트에 대한 반응으로 발생하는 것으로 가정해 봅시다. 사용자가 버튼을 반복해서 눌렀을 때, 앱은 배열의 다음 요소를 프린트합니다.

```swift
var array = [1, 2, 3]
var currentIndex = 0

//버튼의 인터페이스 빌더와 연결되어있는 액션 메소드
@IBAction func printNext(_ sender: Any) {
  print(array[currentIndex])
  
  if currentIndex != array.count - 1 {
    currentIndex += 1
  }
}
```

이전 코드와 동일한 컨텍스트에서 생각해봅시다. 사용자가 버튼을 눌렀을 때, 배열의 모든 요소가 프린트 될까요? 그렇다고 말할 수 없을거다. 다른 비동기 코드가 마지막 요소를 프린트 되기 전에 삭제해버릴 수도 있다. 아니면 인덱스가 움직이고 난 다음에 컬렉션의 시작 부분에 새로운 요소를 넣을 수도 있다.

또 생각해볼 수 있는 것은 지금은 `currentIndex` 에 접근하는 것은 `printNext(_:)` 뿐이지만, 다른 코드가 `currentIndex`를 바꿔버릴 수도 있습니다.

<br />

비동기 코드를 작성할 때 생각해보아야 할 핵심은 **작업 수행 순서**와 **변경 가능한 공유 데이터** 입니다. RxSwift가 바로 이런 점에서 강점을 가집니다~! 

<br /><br />

<br />

## Asynchronous programming 용어

RxSwift에서 몇가지 언어는 비동기, 반응형, 함수형 프로그래밍과 밀접하게 관련되어 있기 때문에 아래와 같은 기본 용어를 이해하면 좋습니다.

### 1. State, and specifically, shared mutable state (상태, 공유 가변 상태)

상태를 정의하는 것은 다소 어려울 수 있습니다.

처음에 컴퓨터를 사서 실행했을 때는 정상적으로 동작하지만, 사용한지 며칠 혹은 몇 주 후에 이상하게 동작하거나, 작업이 갑자기 중단될 수 있습니다. 하드웨어와 소프트웨어는 그대로지만, 상태가 변한 것입니다. 재시작하자마자 동일한 하드웨어와 소프트웨어의 조합이 한 번 더 잘 작동할 것입니다.

메모리에 있는 데이터, 디스크에 저장된 데이터, 사용자의 입력에 작동하는 모든 artifacts, 클라우드 서ㅡ에서 데이터를 가져온 후에 남은 모든 traces들 등등...이런게 모두 합쳐진게 랩탑의 상태가 됩니다.

<br /><br />

### 2. Imperative programming (명령형 프로그래밍)

명령형 프로그래밍이란 명령문을 사용해서 프로그램의 상태를 변화시키는 프로그래밍 패러다임 입니다. 명령형 코드를 사용하면 앱에게 정확히 언제 어떻게 어떤 작업을 할지에 대해 알려줍니다.

명령형 코드는 컴퓨터가 이해하는 코드와 비슷합니다. 모든 CPU는 간단한 명령의 시퀀스를 따릅니다. 이럴 때 문제는 복잡한 비동기 앱에서 특히 공유 가변 상태가 포함될 때 명령형 코드를 짜는 것이 어려울 수 있습니다.

```swift
override func viewDidAppear(_ animated: Bool) {
  super.viewDidAppear(animated)
  
  setupUI()
  connectUIControls()
  createDataSource()
  listenForChanges()
}
```

이 뷰 컨트롤러 자체의 프로퍼티들을 업데이트 할까요? 더 깊게는 이 메소드들이 올바른 순서로 호출될까요? 아마도 누군가는 무심코 이 메소드들의 호출 순서를 바꿔서 커밋했을 수도 있습니다. 메소드 호출 순서가 바껴서 앱이 원하는 바와 다르게 실행될 수도 있습니다.

<br /><br />

### 3. Side effects

이제 가변 상태와 명령형 프로그래밍에 대해 알았으므로, 이런 이슈들을 side effects 관점에서 볼 수 있습니다.

side effects는 코드의 현재 범위의 바깥에 있는 상태를 변경하는 것을 의미합니다. 예를 들어 위에 있는 `viewDidAppear(_:)` 메소드를 보면 `connectUIControls()`는 아마도 어떤 이벤트 핸들러들이랑 UI 컴포넌트들을 붙이는...결합시키는... 작업을 할 것 입니다. 이 작업은 뷰의 상태를 변경시켜 side effect를 발생시킵니다. 즉, 앱은 `connectUIControls()`를 실행하기 전과 후에 다르게 동작할 것입니다.

디스크에 저장되어있는 데이터를 변경하거나, 화면의 label의 텍스트를 업데이트할 때마다 side effects를 발생시키는 것입니다.

side effects 자체는 나쁜 것이 아닙니다. side effect를 발생시키는 것이 프로그램의 목표 아닐까요? 프로그램의 실행이 끝난 후에는 상태를 변경해야할 것 입니다. 실행된 후에 아무것도 하지않으면 쓸모없는 앱이 될 것입니다.

<p align="center"><img width="458" alt="image-20200210173405344" src="https://user-images.githubusercontent.com/16719527/74135065-f9b7cb80-4c2e-11ea-99fa-2eafc0e2ac36.png"></p>

Side effects를 발생시키는데에 중요한 관점은 이것을 *통제할(controlled)* 수 있어야 한다는 것 입니다. 어떤 코드가 side effect를 발생시키는지, 어떤 코드가 단순히 작업만 하고, output 데이터를 만들어내는지 확인할 수 있어야 합니다.

<br />

RxSwift는 다음 두 가지 개념으로 위에서 발생하는 문제를 해결하고자 합니다.

<br /><br />

### 4. Declarative code (선언형 코드)

명령형 프로그래밍에서는 마음대로 상태를 변경시킬 수 있습니다. 반면에 함수형 프로그래밍에서는 side effects를 만드는 코드를 최소화 해야 합니다. 개발자는 이런 개념들 사이에서 균형을 잘 잡아야 합니다. RxSwift는 명령형 프로그래밍과 함수형 프로그래밍의 장점들을 결합합니다.

선언형 코드를 사용하면 동작을 정의할 수 있습니다. RxSwift는 관련된 이벤트가 발생할 때마다 관련된 동작들을 실행시키고, immutable하고 독립된 데이터를 제공합니다.

이런 방식은 비동기 코드에서 할 수 있지만, 간단한 for 루프에서도 같은 동작을 할 수 있습니다. 즉, immutable한 데이터로 작업하고 순차적이고 결정적인 방식으로 코드를 실행시킬 수 있습니다.

<br /><br />

### 5. Reactive systems

반응형 시스템은 다소 추상적인 용어로, 다음과 같은 특성을 전부 혹은 대부분 나타내는 웹이나 모바일 앱을 의미합니다.

- **Responsive (반응적인)**

  항상 UI를 앱의 최신의 상태로 유지시켜야 합니다.

- **Resilient (회복하는...? 원상태로 돌아가는)**

  각 동작들은 독립적이어야 하고, 유연한(flexible) 에러 처리를 지원해야 합니다.

- **Elastic (탄력적인)**

  코드는 다양한 워크로드를 처리하며 lazy pull-driven(..? [읽어보기](https://academy.realm.io/kr/posts/welcome-to-reactive-world/)) 데이터 컬렉션, 이벤트 조절 및 리소스 공유와 같은 기능을 구현합니다.

- **Message driven**

  컴포넌트들은 재사용성과 독립성을 위해서 메세지 기반의 커뮤니케이션을 사용하여 lifecycle과 클래스 구현을 분리합니다.

<br />

<br /><br />

-----

- Artwork/images/designs: from RxSwift: Reactive Programming in Swift book, available at http:// www.raywenderlich.com.