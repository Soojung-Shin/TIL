# Multithreading (멀티스레딩)

여기서 다루는 멀티스레딩의 목표는 UI가 돌아가는 메인 큐에서 실행시간이 긴 작업들을 다른 스레드로 빼는 것이다. 왜냐하면 앱은 UI의 반응성이 좋아야하기 때문이다. 사용자가 화면을 터치하면 그에 대해 즉각적으로 반응할 수 있어야 하며 앱이 멈추면 안된다. 단 1초라도 앱이 반응하지 않는 것은 사용자 입장에서는 꽤 오랜 시간이다. 멀티스레딩으로 훨씬 더 많은 작업을 할 수 있지만 여기서 우리는 실행시간이 긴 것들을 메인 큐에서 제외하는 것에 집중해보겠다.

<br />

### 스레드의 작동 방식

iOS에서 멀티스레딩은 큐를 이용해 작동한다. iOS 멀티스레딩 큐에는 코드 블럭들이 들어 있다. 이 큐에 집어넣는 것은 거의 대부분 클로저다. 큐는 여러 개고 다양한 종류들이 있다. 이 큐에 스레드를 가진 시스템이 접근한다. 스레드는 실행 스레드를 말한다. 다시말해 코드를 실행할 기회를 의미한다. 이 스레드들은 병렬로 작동할 수 있다. 만약 멀티프로세서나 멀티코어프로세서를 사용한다면 실제로 병렬로 작동시키는 것이 가능하다. 하지만 싱글코어나 싱글 스레드로 실행시킨다면 해당 운영체제는 시간을 작게 나누어 모든 스레드에 어떻게 그 시간을 분배할지 알고 있다. 그 후에 운영체제는 큐에 접근해 실행할 것을 꺼낸다.

<br />

### 큐

두 가지 큐가 있다. 하나는 직렬 큐로 iOS가 접근해 큐에서 하나를 꺼내고 해당 작업이 완료될 때까지 실행시킨다. 그럼 다시 큐로 돌아와 다른 하나를 꺼내어 실행시키는데 이를 직렬 큐라고 한다.

다른 하나는 병렬큐다. iOS가 큐에 접근해 하나를 꺼내어 실행시킨다. IOS가 사용 가능한 다른 스레드가 있다면 큐에 접근해서 스레드를 꺼내 실행시키는데 이는 그 전의 작업이 끝나기 전에 이루어질 수도 있다. 이런 식으로 두 개, 세 개, 네 개, 혹은 열 개의 작업을 같은 큐에서 꺼내어 동시에 실행 시킬 수 있다.

우리가 원하는 것은 UI가 막히지 않는 것이다. **UI는 싱글 직렬큐에서 실행되는데 이를 메인 큐라고 한다.** 이 큐에서 UI가 실행될 뿐만 아니라 UI를 위해 실행되는 코드 블록은 오직 이 큐에만 저장된다. 따라서 UI와 관련된 모든 것들을 여기에 저장한다. 따라서 예를 들면 같은 곳에 무언가를 그리려는 서로 다른 두 실행 스레드 같은 것을 우리는 멀티스레드에 대해 신경쓰지 않아도 된다. 왜냐하면 모든 그림, 모든 UI 활동은 이 하나의 큐에서 일어나기 때문이다. 직렬큐이기 때문에 모두 하나의 스레드에서 실행된다. 따라서 멀티스레드 UI와 관련된 활동은 전혀 걱정하지 않아도 된다.

큐가 작동되는 방식은 터치 이벤트가 일어나기를 기다리고 있다가 터치 이벤트가 일어나면 이를 처리하고 어떤 코드가 실행되야 할지 알아내어 코드를 실행시킨다. 그럼 다시 조용한(quite) 상태로 돌아와 다른 터치 이벤트를 기다린다. 대기 상태에 있을 때라도 메인 큐에서 무언가를 꺼내 실행시킬 수 있다.

코드 블록들을 메인 큐에 넣으면 이는 UI 스레드에서 실행될 것이다. 메인 큐는 메인 스레드에서 실행된다. 따라서 다른 모든 것들은 메인 큐에서 제외해야 한다. 오랜 시간 기다려야 하는 작업이나 네트워크를 기다리는 것에 블로킹된 작업들을 말하는 것! 그런 작업들은 메인 큐에서 반드시 제외되어야 한다! 그럼 이런 작업들은 어디에 넣어야 할까? 바로 **글로벌 큐**다~!! 우리가 직접 큐를 만들 수도 있다. 여기서는 네 개의 글로벌 큐 중에 하나를 사용할 것이다. 그 큐들은 병렬큐인데 실행할 코드를 넣으면 시스템이 접근해 이를 실행시킬 것이다. 여기에 어떤 작업을 넣던지 상관없다. UI와 관련된 코드만 아니면 된다. 그 외에는 원하는 모든 것을 실행시킬 수 있다.

<br />

<br /><br />

## 큐에 접근하기

### DispatchQueue

`DispatchQueue`는 우리가 **GCD(grand central dispatch)**라고 부르는 것의 일부다! 이 큐에 코드 블록들을 디스패치하기 때문이다.

### - main queue

메인 큐는 모든 UI 작업이 일어나는 곳이다.

메인 큐를 어떻게 가져올 수 있을까? `DispatchQueue`에는 메인 큐를 제공하는 `main`이라는 정적 변수를 가지고 있다.

```swift
let mainQueue = DispatchQueue.main
```

<br />

### - Global queue

글로벌 큐는 좀 더많은 표현을 가진다. 네 가지 종류의 큐가 있다. 각자의 서비스의 품질(**Quality of Service, QoS**)에 따라서 다르게 사용한다. 서비스의 품질은 우리가 집어넣는 코드가 어떤 종류의 작업을 하는지를 의미한다.

```swift
let backgroundQueue = DispatchQueue.global(qos: DispatchQoS)
```

<br />

#### - QoS

- **DispatchQoS.userInteraction**
  사용자가 화면에서 드래그나 축소 등의 동작을 하는 중간에 메인 큐가 아닌 다른 큐에서 빠르게 처리하고 동작 중간에 다시 메인 큐로 돌아오기를 원할 때 사용한다. 즉, 매우 인터렉티브하고 작은 분량의 작업인데 메인 큐가 아닌 곳에서 이루어지는 경우에 사용한다.
  거의 사용하지 않는다. 왜냐하면 매우 작고 빠르게 실행되는 작업이라 이를 메인 큐에서 처리하는 경우가 대부분이기 때문이다. 어쨌거나 이 작업의 차례가 될 때까지 메인 큐에서 기다려야하긴하겠지만..ㅎㅎ
- **DispatchQoS.userInitiated**
  가장 흔하게 사용되는 큐로 시간이 걸리는 작업에 보통 사용한다. 사용자가 이 작업을 즉시 요청한 경우에 사용한다. 버튼을 누른다거나 화면을 스와이프 하는 등 사용자에 의해 어떤 일이 일어나도록 요청되어진 작업들을 말한다. 이런 동작들은 가능한 빠르게 완료되어야 한다. 백그라운드에서 실행되서 메인 스레드에서 실행되지는 않지만 가능한 빨리 완료되어야 한다. 따라서 이 큐는 매우 높은 우선순위를 가진다. iOS가 이 큐에서 실행할 작업을 꺼내면 우선순위가 매우 높은 스레드에서 실행될 것이다.
- **DispatchQoS.background**
  사용자가 즉시 요청한 것은 아니지만 되도록 빨리 완료되면 좋은 작업들을 말한다.
- **DispatchQoS.utility**
  background보다 더 낮은 우선순위를 가진다. 앱 아키텍처의 일부분으로써 실행되는 작업들이다.
  예를 들면 큰 용량의 데이터베이스가 있고 매주 특정한 양의 데이터를 가공하거나 데이터베이스에서 삭제하는 작업 등을 할 때, 이는 단순한 유틸리티 작업이기 때문에 낮은 우선순위로 실행할 수 있다.

<br />

`DispatchQueue` 생성자에 `label` 인수를 넣어 호출해 우리만의 큐를 생성할 수도 있다. `label`은 디버거에 나타나기 때문에 어떤 큐를 나타내는지 알 수 있다. 디버거는 큐를 전폭적으로 지원하고 있기 때문에 어떤 작업이 어떤 스레드에서 동작하는지 보여준다.

<br /><br />

### OperationQueue

`OperationQueue`와 `Operation`와 같은 다른 API도 있다. 이 두 클래스는 많은 병렬 프로세싱이 필요한 거대한 수학 방정식을 계산할 때 사용된다. 병렬 작업들은 서로 의존되는 경우가 많은데, `Operation`은 의존성을 설정할 수 있도록 해준다. 예를 들어 어떤 코드 블록에 의존하는 작은 코드 블록이 있다면 이것들을 다 실행하고 필요한 블록이 종료되길 기다리게 할 수 있다. 필요하다면 객체 지향적으로 만들어진 `OperationQueue`와 `Operation` API를 사용해 이를 해결할 수 있다.

<br />

<br /><br />

## 큐에 코드 블럭 넣기

메인 큐이거나 특정한 QoS을 가진 백그라운 병행큐를 가졌을 때, 큐에 코드 블럭을 어떻게 넣을 수 있을까?

```swift
queue.async { ... }
queue.sync { ... }
```

각각의 함수는 하나의 인수를 필요로 한다. 인수는 코드 블록, 즉 *클로져*를 말한다. 이 함수는 큐에 우리가 보낸 블록을 넣는다.

**async(비동기)**는 큐에 블록을 넣고 바로 반환한다. 그리고 원래 실행하던 코드의 다음 줄을 계속 실행한다. 큐에 들어간 블록은 결국 누군가 꺼내어 실행하겠지만 일단 async에서는 바로 반환한다.

**sync(동기)**는 큐에 블록을 넣고 실행을 멈춘다. 누군가 큐에서 이 블록을 꺼내 실행을 완료할 때까지 기다리게 된다. 메인 큐에서는 절대 sync 함수를 사용하지 않겠지? 왜냐하면 메인 큐는 절대 멈춰지기를 바라지 않으니까! 그러나 메인큐가 아닌 다른 큐에서는 sync를 사용할 수 있다. 실제로 다른 큐에 있을 때 메인 큐가 어떤 작업을 끝내게 하려고 sync를 사용한다.

대부분은 async를 사용한다. 보통은 어떤 작업이 언제 실행되는지 관계없이 그냥 실행될 수 있을 때 실행되기를 원하기 때문이다.

멀티스레딩으로 다양한 것들을 할 수 있다. 코드의 임계구역을 보호하거나(코드 내 보호되어야 하는 구역) 동기적으로 디스패치를 하거나 락을 거는 등의 일을 할 수 있다.

<br />

<br />

<br />

## 사용

코드 블럭을 인수로 받는 API가 있다. 이 API가 블록을 실행할 때 작업이 끝나거나 에러를 만나면 블록을 메인 큐 밖에서 실행시킨다. 이 API를 iOS에서 호출할 때는 iOS에게 실행하라고 제공하는 블록에 어떠한 UI도 포함되지 않도록 매우 조심해야 한다. 만약 UI가 포함됐다면 다시 메인 큐로 보내야 한다. 왜냐하면 메인 큐에서는 UI와 관련된 것만 가능하기 때문이다. 여기서는 `DispatchQueue`를 사용할 것이다. 

<br />

### URLSession

`URLSession`은 네트워크를 통해 URL에서 정보를 불러올 때 사용한다. 네트워크에 무언가를 요청하는 훨씬 더 정교한 방법이다. 매우 간단한 API로, 특정한 설정으로 `URLSession`을 생성하기만 하면 된다. 이것의 좋은 점은 이를테면, 타임아웃을 5초로 설정할 수 있다. `Data` 객체에는 이미 내장된 타임아웃이 있어서 설정이 불가능하지만, 여기서는 네트워크에서 나오기 전에 얼만큼 기다릴 것인지를 설정할 수 있는 등 여러가지가 가능하다. 보통 디폴트로 설정하고, `session`을 생성한다.

<br />

```swift
let session = URLSession(configuration: .default)

if let url = URL(string: "http://stanford.edu/...") {
  let task = session.dataTask(with: url) { (data: Data?, response, error) in
     ...
                                          
  //이 클로져는 URLSession이 데이터를 얻었을 때 호출하는 클로저다. 클로저의 인수로 data를 받고, http 응답에 따른 response와 error도 인수로 받는다.
  //중요한 것은 클로저를 주었다는 것~!! 이 클로저는 메인 큐의 밖에서 실행된다.
  //만약 여기서 UI와 관련된 작업을 하고 싶다면, 예를 들어 돌려받은 데이터를 UI에 넣는다든지 등의 작업을 하고 싶다면
  //이 클로저에서 가능할까? 안된다~! 왜냐면 메인 큐가 아닌 곳에서는 UI와 관련된 것을 할 수 없으니까!
  //그럼 UI와 관련된 작업을 하고싶으면 어떻게 해야될까? 아래처럼 해야한다.
                                          
  	DispatchQueue.main.async {
      //이렇게 메인 큐로 작업을 다시 보내서 하면 된다. DispatchQueue.main을 이용해 메인 큐를 부르고 async를 통해 메인 큐에 클로저를 넣는다. 이 안에서 UI 관련 작업을 처리하면 되는 것!
      //하지만 여기서 타이밍에 관한 문제를 생각해봐야 한다. 아래를 보시라...
    }
  }
  
  //어떤 정보를 가져오기 위해서 우리가 할 일은 URL을 생성하고, 그 URL로 session의 dataTask 함수를 호출하는 것이다.
  //이 함수를 호출하면 데이터 태스크를 생성하는데 이 태스크는 데이터를 가져오는 일을 한다. 그 후 실행이 일시 중지 된다.
  task.resume()
  //실행을 재개하라는 명령으로 동작을 다시 시작되게 한다.
}
```

<br />

<br />

### Timing

<p align="center"><img width="812" alt="image-20191230191503265" src="https://user-images.githubusercontent.com/16719527/72700233-a6ea7700-3b8e-11ea-9db7-7dddda910fa9.png">
</p>

위 사진과 같은 코드가 있을 때 어떤 일이 일어나는지 차례로 살펴보자.

 <br />

1. `URLSession`을 요청하는 a가 실행된다.
2. `dataTask`를 생성하는 b가 실행되고 b는 즉시 리턴된다. 바로 `dataTask`를 생성하고 클로저를 붙잡고 잠시 머무르다가 멈춰있던 작업을 다시 시작한다.
3. b가 반환되면 g를 실행한다. `resume()`을 명령해서 네트워크를 통해 URL 데이터를 패치하는 작업을 메인 큐가 아닌 백그라운드에서 시작하게 된다.
4. h가 실행된다. 왜냐하면 `resume()`은 백그라운드에서 바로 시작됐지만 라인 h는 포어그라운드에서 계속되기 때문이다. 
5. 약 5초 뒤, 혹은 5시간 뒤, 혹은 5분 뒤든지 어쨌거나 라인 c가 실행된다. 이 라인은 URL에서 데이터가 오면 실행된다. 이제 그 데이터를 처리하거나 가공하거나한다.
6. 그럼 d가 실행된다. UI 작업이 필요하기 때문이다. 메인 큐에 UI 작업을 하는 클로저를 디스패치하고 메인 큐에서 실행될 수 있도록 해당 라인이 실행된다. 그러나 이 클로저에 앞서 메인 큐가 처리해야할 다른 작업으로 바쁠수도 있기 때문에 이 명령이 바로 실행되지는 않을 수 있다.
7. 대신 라인 f가 바로 실행될 것이다. f가 실행됐는데 라인 e는 아직 실행되지 않았다.
8. 메인 큐가 한가하고 준비가 되었을 때 라인 e가 최종적으로 실행된다. 앞에 있는 다른 모든 클로저들이 실행되고 난 뒤에 말이다.

 <br />

코드를 보면 모든 명령이 위에서부터 차례로 실행될거라고 생각하겠지만 백그라운드 스레드에서 일어나는 일이기 때문에 코드 순서와는 조금 다르게 실행된다.

요약하자면 순서는 a - b - g - h - c - d - f - e 로 실행된다. 그러나 이 순서는 가장 일어날 법한 순서일 뿐이다. 왜냐하면 스레드에서는 여러 개가 동시에 실행되기 때문이다. UI 작업을 하는 라인 e가 f보다 먼저 실행될 수도 있다. 라인 e가 메인 큐에 디스패치 되면 메인 큐는 우선순위가 매우 높은 큐이기 때문에 즉시 큐에 들어온 작업을 라인 f가 실행되기도 전에 실행시킬 수도 있다. 만약 싱글 프로세스를 사용한다면 분명히 가능한 일이다.

 <br /><br />

<br />

# 멀티스레드의 클로져에서 주의할 점

```swift
DispatchQueue.global(pos: .userInitiated).async {
  let urlContents = try? Data(contentsOf: url)
  if let imageData = urlContents {
    self.image = UIImage(data: imageData)
  }
}
```

1. 위 코드처럼 멀티스레드에서 `self`를 사용해 이미지를 불러오는 중에 사용자가 백버튼을 눌러 해당 뷰 컨트롤러에서 빠져나온다면? 그럼 네비게이션 컨트롤러에서 pop되었기 때문에 해당 뷰 컨트롤러는 힙에서 사라져야한다. 하지만 현재 클로져에서 `self`로 해당 뷰 컨트롤러를 가리키고있기 때문에 작업이 완료될 때 까지 힙에서 사라지지 않고 유지될 것이다. 따라서 힙에서 유지되지 않도록 클로져 내부에서 `self`를 `weak`로 지정해주어야 한다. 클로저에서 멀티스레드를 사용한다면 `weak`를 사용해야할지 아니면 힙에 붙잡아 두려고 하는지에 대해서 꼭 고민해봐야한다.

2. 또 다른 문제점은 global 큐에서 UI를 변경하고 있다는 것이다. UI를 변경하는 부분을 다시 메인 큐로 꺼내야한다. 그럼 해당 작업 차례가 되었을 때 메인 큐에서 실행될 것이다.

3. 다른 문제점이 하나 더 있다. 만약 해당 뷰 컨트롤러에서 이미지를 불러오다가 사용자가 다른 이미지를 불러오도록 요청했을 때, 그 전 작업에서 요청한 이미지가 로딩이 완료되어 불러진다면? 그래서 코드에 우리가 요청한 URL이 맞는지 확인하는 과정을 추가해야한다. 타이밍의 문제다. 멀티스레딩을 사용할 때는 어떤 작업은 시간이 좀 걸리기 때문에 타이밍 문제를 꼭 생각해봐야 한다. 어떤 작업에서 요청한 값과 반환된 값이 달라질 수도 있다는 것이다.

<br /><br />

아래는 수정된 코드다.

```swift
DispatchQueue.global(pos: .userInitiated).async {
  let urlContents = try? Data(contentsOf: url)
  DispatchQueue.main.async { [weak self] in
    if let imageData = urlContents, url == self?.imageURL {
      self?.image = UIImage(data: imageData)
    }
  }
}
```

위 코드를 꼭 이해해야 한다. `weak self`, 사용자가 요청한 값이 맞는지 확인하는 것, 메인 큐로 다시 디스패치 하는 것을 꼭 확인하자~!!!!!!